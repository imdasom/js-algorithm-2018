# 객체지향이라고 부르려면!
## value & identifier (값 & 식별자)
- 식별자지향 : OOP시스템
- 값지향 : 함수형시스템 (불변성/순수함수 등을 지향하기 때문에)
- OOP 시스템에서는 값으로 비교하는 것이 아닌 식별자로 비교하도록 설계/구현해야 한다
- 예를 들면, "a" != "a" 이어야 한다. "a"라는 값이 같다고 해서 같은 것이 아니다. 
- 실제 메모리상에 ref가 같아야 같은 것이 되어야 객체기반의 데이터가 되는것

## polymorphism 다형성
이 두가지가 충족되면 다형성이라고 한다
```
- substitution : 대체가능성
- internal identity : 내적동질성
```

## Obejct
이 두가지가 충족되면 객체라고 한다
- Encapsulation of Functionality > 기능의 캡슐화를 달성해야 한다 > 변화에 대응하기 위해 로직이 격리되어야 하기 때문에
- Maintenance of State > 상태를 관리해야 한다

## 궁극적인 목표는 Isolation
결국 OOP의 궁극적인 목표는 로직을 격리하는 것이다. A기능의 변화되었는데 수정해야 하는 파일이 많다? 격리가 제대로 되지 않은 것이라고 볼 수 있겠다.

# Theater
```java
public class Theater {
  final private List<TicketOffice> ticketOffices = new ArrayList<>();
  final private Long fee;
  
  public Theater(Long fee) {
    this.fee = fee;
  }
  
  Long getFee() {
    return this.fee;
  }
  
  public void setTicketOffices(TicketOfflice ... ticketOffices) {
    this.ticketOffices.addAll(Arrays.asList(ticketOffices));
  }
  
  public void setTicket(TicketOffice ticketOffice, Long num) {
    if (!ticketOffices.contains(ticketOffice)) {
      return;
    }
    while(num-- > 0) {
      ticketOffice.addTicket(new Ticket(this)); // (1)
    }
  }
  
  public void steInvitation(Audience audience) {
    audience.setInvitation(new Invitation(this)); // (1)
  }
  
  public boolean enter(Audience audience) {
    // Audience야 표줘봐
    Ticket ticket = audience.getTicket();
    // 표야 나 A극장인데 너 A극장표맞니? 정상이면 들어와/말아 리턴
    return ticket.isValid(this); (1)
  }
}
```
- (1) 티켓을 만들때, 입장권을 만들때, 표를 검사할때 > 이 극장의 티켓이라는 것을 알려주어야 한다. 그냥 this.getName() 극장명 넘겨주면 되지않나? 싶지만, 식별자로 '값'을 넘기면 안된다. 반드시 객체의 reference = 식별자를 넘겨주어야 한다.

# Ticket
```java
public class Ticket {
  final static public Ticket EMPTY = new Ticket(null); // (3)
  final private Theater theater; //(1)
  private boolean isEntered = false;
  
  public Ticket(Theater theater) {
    this.theater = theater;
  }
  
  public boolean isValid() {
    if (isEntered || theater != this.theater || this == EMPTY) {
      return false;
    } else {
      isEntered = true;
      return true;
    }
  }
  
  public Long getFee() {
    return theater.getFee(); // (2)
  }
}
```
- (1) Theater는 티켓생성때 정해지고, 변할수없으므로 final 선언
- (2) fee값을 가져올 때 포인터로 사용하고 있다 = theater.getFee()로 값을 가져오고 있다. 만약 theater.fee로 사용한다면 
    - 나중에 theater의 fee의 필드명이 변경되거나 타입이 변경되는 등의 변화가 일어나면 이 클래스도 같이 수정되어야 한다.
    - 나중에 theater의 fee값이 바뀌면, 이 클래스에느 반영되지 않는다. 동적으로 값을 가져올 수 없게 됨
- (3) null 혹은 아무행동도 하지 않는 협력자가 필요하다면 null 혹은 아무행동도 하지 않는 역할을 대체하는 객체를 만들어서 써라. (Null객체 패턴 참고)

# TicketOffice
```java
public class TicketOffice {
  private Long amount;
  private List<Ticket> tickets = new ArrayList<>();
  
  public TicketOffice(Long amount) {
    this.amount = amount;
  }
  
  public void addTicket(Ticket ticket) {
    this.tickets.add(ticket);
  }
  
  public Long getTicketPrice() {
    if (ticketes.size() ==  0) {
      return 0L;
    } else {
      return tickets.get(0).getFee(); // (1)
    }
  }
}
```
- (1) 다이어그램을 보면 TicketOffice는 Theater를 모르고 있다. 그럼 티켓가격은 어떻게 아나? 티켓을 통해 알 수 있다. 최대한 Theater에 의존하지 않고 단방향으로 유지하도록 해야한다.
