# 14_일관성 있는 협력
#### 객체는 협력을 위해 존재한다. (p470)
객체지향 패러다임의 장점은 > 설계를 재사용할 수 있다는 것이다.  
재사용은 > 공짜로 얻어지지 않는다.  
재사용을 위해서는 > 객체들의 협력방식을 일관성 있게 만들어야 한다.

#### 유사한 기능을 구현하기 위해 유사한 협력패턴을 사용하라 (p470) 
  
#### 일관성 있는 협력 패턴은 코드가 이해하기 쉽고 유연해진다는 것이 이번 장의 주제!  
  
### 01_핸드폰 과금 시스템 변경하기
#### 11장에서 나왔던 요금제 예제코드를 다시 보자
- 그림11.1  (p354)
- 그림11.2  (p355)
- 그림11.11 (p375)
- 그림11.12 (p377)
- 그림11.13 (p377)

#### 이번장에서는 기본정책이 4가지로 구분된다. 부가정책은 11장과 동일!
- 그림 14.2는 그림 11.12, 11.13을 변경/확장한 것
  
#### 시간대별 방식 구현하기 (p474)
```
- 11장의 심야할인 요금제를 다시 보자. 일자에 대한 고려가 돼 있지 않다.
- 기간을 의미하는 DateTimeInterval 클래스를 추가한다.
- DateTimeInterval에 from, to가 요금을 부과할 기간을 의미한다.
- 이제 기간을 의미하는 클래스가 생겼다. 이제 요금을 계산해야 한다. 누가? 새로운 정책 TimeOfDayDiscountPolicy 클래스가!
- 일자별/시간별로 구분해서 요금을 계산해야 한다 > 적절한 객체에 책임을 할당해야 한다
```

##### 1. 통화기간을 일자별로 분리한다. DateTimeInterval에 여러일자가 존재한다면, 일자별로 분리하여 List<DateTimeInterval>로 만들어야 한다.
그림 14.7 ~ 14.8 (p479)

##### 2. 계산을 하려면 시간별 요금에 대한 정보가 필요하다. 그건 TimeOfDayDiscountPolicy가 가지고 있다.
그림 14.9

##### 3. 일자별로 분리된 기간은, 다시 시간대별로 계산한다. DateTimeInterval과 TimeOfDayDiscountPolicy를 통해 요금을 계산한다
p481 : TimeOfDayDiscountPolicy
```java
package org.eternity.billing.step01;

import org.eternity.money.Money;
import org.eternity.time.DateTimeInterval;

import java.time.Duration;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

public class TimeOfDayDiscountPolicy extends BasicRatePolicy {
    private List<LocalTime> starts = new ArrayList<LocalTime>();
    private List<LocalTime> ends = new ArrayList<LocalTime>();
    private List<Duration> durations = new ArrayList<Duration>();
    private List<Money>  amounts = new ArrayList<Money>();

    @Override
    protected Money calculateCallFee(Call call) {
        Money result = Money.ZERO;
        
        /**
         * call.splitByDay()로 일자별로 나눈 뒤
         * 시간별 요금제 리스트로 for문을 돈다
         */
        for(DateTimeInterval interval : call.splitByDay()) {
            for(int loop=0; loop < starts.size(); loop++) {
                result.plus(
                    amounts.get(loop).times(
                        Duration.between(
                            from(interval, starts.get(loop)), 
                            to(interval, ends.get(loop))
                        ).getSeconds() 
                        / 
                        durations.get(loop).getSeconds() // durations에는 요금부과 시간을 가지고 있다. 10초
                    )
                );
            }
        }
        return result;
    }
    
    private LocalTime from(DateTimeInterval interval, LocalTime from) {
        return interval.getFrom().toLocalTime().isBefore(from) ? from : interval.getFrom().toLocalTime();
    }

    private LocalTime to(DateTimeInterval interval, LocalTime to) {
        return interval.getTo().toLocalTime().isAfter(to) ? to : interval.getTo().toLocalTime();
    }
}
```
