# 오브젝트2 2회차(1)

## 계약 contract
- 전달받은 메세지의 규격 (precondition) : sender가 항상 제대로된 메세지를 보낼 것이라 생각하면 안된다. 받는쪽에서 체크해야 한다
- 전달할 메세지의 규격 (postcondition) : 메세지전달하기전에 확인해야 한다
- 객체 자신의 규격 (class invariant) : 내 상태가 지금 메세지를 처리할 수 있는 조건인가 확인. 불변성을 확보해야 한다
- 위임된 책임의 컨텍스트 : 이 메세지가 지금 컨텍스트에 맞는건가?

## invariant
- 메세지와 무관한 객체의 상태
- 객체가 메세지를 수신하기전 상태
- 메세지를 처리하기전 객체의 property값을 점검해야 한다
- 값점검은 어떻게 하나? DI에게 위임하거나 초기화 할당으로 처리

```java
public class Plan {
    // @Setter
    // private Calculator calc;  // (1)
    private Calculator calc = new Calculator();  // (2)
    private Set<Cell> calls = new HashSet<>();
    ...
}
```
- (1) calc가 초기화되지 않은 상태로 호출될 위험이 있다. 초기화하지 않으면 NullPointerException가 어딘가에서 생긴다
- (2) null을 방지하기 위해 항상 필드를 초기화해준다 --> null을 대신하는 EMPTY객체를 할당해라

## 사전조건 precondition
- 일반적으로 validation, required 등의 이름으로 불린다
- 넓은 범위의 프로그래밍이론에서는 `화이트리스트 이론`이라고 한다
- 사전조건 == 쉴드패턴

#### 구현방법
- 브릿지역할을 하는 타입을 만들어서 validation을 위임한다 (예: Integer값을 감싸서 Money객체로 만든다, 기본형도 감쌀수있다 SaftyInteger)
- 메세지를 받으면 필요한 값을 검증해서 return으로 빼버린다. (black list, white list 처리하는 코드를 나눠리 = 쉴드패턴)
- 컴파일러의 기능을 이용한다 (spring에서는 아예 validation 기능을 제공한다 @valid, @NonNull, ...)
```java
public class Plan {
    private Calculator calc = new Calculator();
    public final void addCall(Call call) { // (1) 지금 상태로는 call에 null이 들어올수있다
        calls.add(call);
    }
    public final void setCalculator(Calculator calc) { // (1) 지금 상태로는 calc에 null이 들어올수있다
        this.calc = calc;
    }
}
```
