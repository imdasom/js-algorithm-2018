# 15_디자인패턴과 프레임워크
### 01 디자인패턴과 설계 재사용
- 패턴은 지식 전달과 커뮤니케이션의 수단이 될 수 있다.
- "인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임 시에 알고리즘을 바꿀 수 있게 하자" ==> STRATEGY 패턴을 적용하자

##### 패턴분류
- 패턴의 범위나 적용 단계에 따라 4가지로 나뉜다
- 아키텍처 패턴
- 분석 패턴
- 디자인 패턴
- 이디엄

##### 패턴과 책임-주도설계
- 어떤 책임이 필요한가?
- 이 책임을 어떤 객체에게 할당해야 하는가?
- 유연하고 확장가능한 협력 관계를 구축하기 위해 객체와 객체 간에 어떤 의존성이 존재해야 하는가?
- 패턴은 = 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
- 패턴의 구성요소는 = 클래스가 아니라 '역할'이다.
- 디자인패턴의 구성요소 = 클래스/메서드가 아니라 역할/책임이다.

##### 디자인패턴은 변경을 어떤 변경을 어떻게 캡슐화했는지를 이해하는 것이다.
기존에는 디자인패턴의 방법과 구현방법에만 관심이 있었고 적용하기 어려웠지만, 이렇게 변경에 초점을 맞추면 디자인 패턴이 다르게 이해되는 것 같다.
```
STRATEGY 패턴
- 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다
- 런타임에 알고리즘을 변경할 수 있다. (합성을 사용하는 방법)
TEMPLATE METHOD 패턴
- 런타임에 알고리즘을 변경할 수 있다. 단, 상속관계를 사용하는 방법이다.
- 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다.
- 다만 합성보다 결합도가 높은 상속을 사용했기 때문에 STRATEGY 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다.
- 하지만 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 STRATEGY 패턴보다 복잡도를 낮출 수 있다는 면에서는 장점이라고 할 수 있다.
BRIDGE 패턴
- 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로 설계를 확장가능하게 만든다.
OBSERVER 패턴
- 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.
COMPOSITE 패턴
- 클라이언트가 개별객체와 복합객체를 동일하게 취급할 수 있다.
DECORATOR 패턴
- 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화 할 수 있다.
```

##### 디자인패턴에서 중요한 것은
- 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다.
- 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.

##### 패턴은 출발점이다
- 패턴이 제시하는 구조를 맹목적으로 따르는 것은 불필요하게 복잡하고, 난해하며, 유지보수하기 어려운 시스템을 낳는다.
- 패턴을 남용하지 않기 위해서는 다양한 트레이드오프 관계 속에서 패턴을 적용하고 사용해 본 경험이 필요하다.
- 전문가와 초심자의 차이점은 다양한 실물경험을 통해 패턴을 적용해야 하는지, 적용해선 안되는지에 대한 감각을 익히고 있다는 점이다.

