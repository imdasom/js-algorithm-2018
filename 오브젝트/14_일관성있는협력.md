# 14_일관성 있는 협력
#### 객체는 협력을 위해 존재한다. (p470)
객체지향 패러다임의 장점은 > 설계를 재사용할 수 있다는 것이다.  
재사용은 > 공짜로 얻어지지 않는다.  
재사용을 위해서는 > 객체들의 협력방식을 일관성 있게 만들어야 한다.

#### 유사한 기능을 구현하기 위해 유사한 협력패턴을 사용하라 (p470) 
  
#### 일관성 있는 협력 패턴은 코드가 이해하기 쉽고 유연해진다는 것이 이번 장의 주제!  
  
### 01_핸드폰 과금 시스템 변경하기
#### 11장에서 나왔던 요금제 예제코드를 다시 보자
- 그림11.1  (p354)
- 그림11.2  (p355)
- 그림11.11 (p375)
- 그림11.12 (p377)
- 그림11.13 (p377)

#### 이번장에서는 기본정책이 4가지로 구분된다. 부가정책은 11장과 동일!
- 그림 14.2는 그림 11.12, 11.13을 변경/확장한 것
  
#### 시간대별 방식 구현하기 (p474)
```
- 11장의 심야할인 요금제를 다시 보자. 일자에 대한 고려가 돼 있지 않다.
- 기간을 의미하는 DateTimeInterval 클래스를 추가한다.
- DateTimeInterval에 from, to가 요금을 부과할 기간을 의미한다.
- 이제 기간을 의미하는 클래스가 생겼다. 이제 요금을 계산해야 한다. 누가? 새로운 정책 TimeOfDayDiscountPolicy 클래스가!
- 일자별/시간별로 구분해서 요금을 계산해야 한다 > 적절한 객체에 책임을 할당해야 한다
```

##### 1. 통화기간을 일자별로 분리한다. DateTimeInterval에 여러일자가 존재한다면, 일자별로 분리하여 List<DateTimeInterval>로 만들어야 한다.
그림 14.7 ~ 14.8 (p479)

##### 2. 계산을 하려면 시간별 요금에 대한 정보가 필요하다. 그건 TimeOfDayDiscountPolicy가 가지고 있다.
그림 14.9

##### 3. 일자별로 분리된 기간은, 다시 시간대별로 계산한다. DateTimeInterval과 TimeOfDayDiscountPolicy를 통해 요금을 계산한다
p481 : TimeOfDayDiscountPolicy
코드 이해해야 함

#### 요일별 방식 구현하기 (p483)
```
- 요일별 요금은 요일의 목록, 시간, 요금으로 구성된다.
- 시간대별 방식을 구현한 프로그래머는 4개의 List를 이용해서 구현했지만
- 요일별 방식을 구현하는 프로그래머는 규칙을 하나의 클래스에 모아서 구현하는 것이 더 나은 설계라고 판단했다.
- 그 결과 DayOfWeekDiscountRule 클래스가 나왔다.
- 요일별 역시 여러 날에 걸쳐있을 수 있다.
```

#### 구간별 방식 구현하기 (p484)
```
- 잠시 숨을 고르며 지금까지 만든 요금정책을 보자.
- FixedFeePolicy, TimeOfDayDiscountPoliyc, DayOfWeekDiscountPolicy 모두 유사한 문제를 해결하고 있지만
- 설계에 일관성이 없다.
- 자, 그럼 구간별 방식을 구현하려 보니! 3개의 클래스 중 어떤 설계방식을 선택하지 고민이다.
- 더 큰 문제는 3가지 설계방법 모두 큰 문제가 있는 것도 아니다!
- 일단 새로운 방식으로 만들어본다!
```

##### 결론은 유사한 기능은 유사하게 구현해야 한다는 것이다.
객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이다.  
유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것이다!

### 02_설계에 일관성 부여하기
##### 조언1  
일관성 있는 설계를 만들려면 다양한 설계 겅험을 익혀라!  
어떤 변경이 중요한지, 그 변경을 어떻게 다뤄야 하는지에 대한 통찰력이 필요하다.  
당연히 단기간에 쌓아 올리기 어려운 일이다.

##### 조언2
디자인패턴을 학습하고, 변경이라는 문액 안에서 디자인 패턴을 적용해보아라!  
디자인패턴은 특정한 변경에 대한 설계 법칙을 모아놓은 것이다.

##### 조언3
변하는 개념을 변하지 않는 개념으로부터 분리하라  
변하는 개념을 캡슐화하라  
사실 지금까지 이 책에서 설명했던 모든 원칙과 개념들 대부분 변경의 캡슐화라는 목표를 향한다!  

##### 조건로직 대 객체탐색 (p489)
객체지향적인 코드는 조건을 판단하지 않는다. 다음 객체로 이동할 뿐!  
조건로직을 객체이동으로 대체하려면 > 커다란클래스를 작은클래스로 분리해야 한다.  
그럼, 어떤 기준으로 분리하는 것이 좋을까? > 가장 중요한 기준은 변경의 이유와 주기!  

##### 클래스는 명확히 단 하나의 이유에 의해 변경되어야 하고, 클래스 안의 모든 코드는 함께 변경돼야 한다.

##### 캡슐화 다시 살펴보기 (p494)
캡슐화는 단순히 '데이터'를 감추는 것이 아니라 '개념'을 감추는 것이다.  
퍼블릭 인터페이스도 '구현'을 감춘 것이다. 구현을 캡슐화한 것.  
코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.  
그림 14.13
